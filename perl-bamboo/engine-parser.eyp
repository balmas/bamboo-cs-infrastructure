%strict
%prefix Bamboo::Engine::Parser::
#%tree

%token NUMBER = /-?\d+(?:\.\d+)?|\.\d+/
%token DOLLAR_QNAME = /\$[a-zA-Z_][-a-zA-Z0-9_.]*/
%token DOLLAR_INT = /\$\d+/
%token FUNCTION_NAME = /(?:[a-zA-Z_][-a-zA-Z0-9_.]*:)?[a-zA-Z_][-a-zA-Z0-9_.]*\??\*?\s*(?=\([^:])/
%token XMLNS  = /xmlns:[a-zA-Z_][-a-zA-Z0-9_.]*/
%token QNAME  = /(?:[a-zA-Z_][-a-zA-Z0-9_.]*:)?[a-zA-Z_][-a-zA-Z0-9_.]*/
%token NCNAME = /[a-zA-Z_][-a-zA-Z0-9_.]*/

# '*' is MPY if it is not preceeded or succeeded by a '/'

%token LITERAL

%token MPY

#%whites /(\s*(?:\(:.*?:\))\s*)/

%start statements

%%

statements: statement <+ ';'> { Bamboo::Engine::Block -> new( statements => $_[1] ) }
  ;

statement: 
  | expr { $_[1] }
  | let_expr { $_[1] }
  | ns_expr { $_[1] }
  ;

expr: or_expr { $_[1] }
  | range_expr { $_[1] }
  | if_expr { $_[1] }
  | for_expr { $_[1] }
  | quant_expr { $_[1] }
  | with_expr { $_[1] }
  | err_expr { $_[1] }
  ;

err_expr: expr 'err' expr { Bamboo::Engine::Parser::ErrExpr -> new( expr => $_[1], default => $_[3] ) }
  ;

with_expr: expr 'with' expr_set_list { Bamboo::Engine::Parser::WithExpr -> new( expr => $_[1], annotations => $_[3] ) }
  ;

expr_set_list: expr_set <+ ','> { $_[1] }
  ;

expr_set: relative_location_path ':=' expr { Bamboo::Engine::Parser::MemSet -> new( path => $_[1], expr => $_[3] ) }
  ;

let_expr: 'let' DOLLAR_QNAME.name ':=' expr.expr { Bamboo::Engine::Parser::VarSet -> new( name => $name, expr => $expr ) }
  ;

ns_expr: 'let' XMLNS.prefix ':=' LITERAL.uri { $_[0] -> AddNS( prefix => $prefix, uri => $uri ) }
  ;

if_expr: 'if' '(' expr.test ')' 'then' expr.then 'else' expr.else { Bamboo::Engine::Parser::IfExpr -> new( test => $test, then => $then, else => $else ) }
  | 'if' '(' expr.test ')' 'then' expr.then { Bamboo::Engine::Parser::IfExpr -> new( test => $test, then => $then ) }
  ;

for_expr: 'for' for_vars.vars 'return' expr.expr { Bamboo::Engine::Parser::ForExpr -> new( vars => $vars, expr => $expr ) }
  ;

for_vars: for_var <+ ','> { 'for_vars' }
  ;

for_var: DOLLAR_QNAME 'in' expr
  ;

quant_expr: 'some' for_vars 'satisfies' expr
  | 'every' for_vars 'satisfies' expr
  ;

or_expr: and_expr <+ 'or'> { printf STDERR Data::Dumper -> Dump(@_); }
  ;

and_expr: equality_expr { Bamboo::Engine::Parser::AndExpr -> new( set => [ $_[1] ] ) }
  | and_expr 'and' equality_expr { $_[1] -> addAnd( $_[3] ) }
  | and_expr 'except' equality_expr { $_[1] -> addExcept( $_[3] ) }
  ;

equality_expr: relational_expr { $_[1] }
  | additive_expr.left '=' additive_expr.right { Bamboo::Engine::Parser::EqExpr -> new( left => $left, right => $right ) }
  | additive_expr.left '!=' additive_expr.right { Bamboo::Engine::Parser::NeqExpr -> new( left => $left, right => $right ) }
  ;

tuple: '[' list ']' { Bamboo::Engine::Parser::Tuple -> new( values => $_[2] ) }
  ;

list: expr <+ ','> { Bamboo::Engine::Parser::ListExpr -> new( expr => $_[1] ) }
  ;

relational_expr: additive_expr { $_[1] }
  | additive_expr '<' additive_expr
  | additive_expr '>' additive_expr
  | additive_expr '<=' additive_expr
  | additive_expr '>=' additive_expr
  ;

range_expr: additive_expr '..' additive_expr { Bamboo::Engine::Parser::Range -> new( start => $_[1], end => $_[3] ) }
  | additive_expr 'to' additive_expr { Bamboo::Engine::Parser::Range -> new( start => $_[1], end => $_[3] ) }
  ;

additive_expr: multiplicative_expr { $_[1] }
  | additive_expr '+' multiplicative_expr { printf STDERR "additive expr\n\n"; Bamboo::Engine::Parser::AddExpr -> new( left => $_[1], right => $_[3] ) }
  | additive_expr '-' multiplicative_expr { Bamboo::Engine::Parser::SubExpr -> new( left => $_[1], right => $_[3] ) }
  ;

multiplicative_expr: unary_expr { $_[1] }
  | multiplicative_expr MPY unary_expr
  | multiplicative_expr 'div' unary_expr
  | multiplicative_expr 'mod' unary_expr
  ;

unary_expr: union_expr { $_[1] }
  | '-' unary_expr { Bamboo::Engine::Parser::NegateExpr -> new( expr => $_[2] ) }
  ;

union_expr: path_expr <+ '|'>
  ;

path_expr: location_path { $_[1] }
  | primary_expr predicates segment { (defined($_[2]) || defined($_[3])) ? Bamboo::Engine::Parser::PathExpr -> new( primary => $_[1], predicates => $_[2], segment => $_[3] ) : $_[1] }
  ;

segment:
  | '/' relative_location_path { Bamboo::Engine::Parser::ChildSegment -> new( path => $_[2] ) }
  | '//' relative_location_path { Bamboo::Engine::Parser::DescendentSegment -> new( path => $_[2] ) }
  ;

location_path: relative_location_path { $_[1] }
  | absolute_location_path { $_[1] }
  ;

absolute_location_path: '/' { Bamboo::Engine::Parser::Root -> new() }
  | '/' relative_location_path { Bamboo::Engine::Parser::ChildSegment -> new( path => $_[2], root => 'data' ) }
  | '//' relative_location_path { Bamboo::Engine::Parser::DescendentSegment -> new( path => $_[2], root => 'data' ) }
  | axis_name '/' relative_location_path { Bamboo::Engine::Parser::ChildSegment -> new( path => $_[3], root => $_[1] ) }
  | axis_name '//' relative_location_path { Bamboo::Engine::Parser::DescendentSegment -> new( path => $_[3], root => $_[1] ) }
  ;

axis_name: NCNAME '::' { $_[1] }
  ;

relative_location_path: step { $_[1] }
  | relative_location_path '/' step { Bamboo::Engine::Parser::ChildStep -> new( path => $_[1], step => $_[3] ) }
  | relative_location_path '//' step { Bamboo::Engine::Parser::DescendentStep -> new( path => $_[1], step => $_[3] ) }
  ;

step: axis predicates { Bamboo::Engine::Parser::Step -> new( step => $_[1], predicates => $_[2] ) }
  | '.' { Bamboo::Engine::Parser::CurrentContext -> new() }
  | '..' { Bamboo::Engine::Parser::ParentofContext -> new() }
  ;

axis: node_test { Bamboo::Engine::Parser::NodeTest -> new( name => $_[1] ) }
  | NCNAME '::' node_test
  | '@' node_test { Bamboo::Engine::Parser::AttributeTest -> new( name => $_[2] ) }
  ;

predicates: predicate+ { Bamboo::Engine::Parser::Predicates -> new( predicates => $_[1] ) }
  ;

num_expr: additive_expr { $_[1] }
  | range_expr { $_[1] }
  ;

num_list: num_expr <+ ','> { Bamboo::Engine::Parser::NumericSet -> new( values => $_[1] ) }
  ;

predicate: '[' expr ']' { Bamboo::Engine::Parser::FunctionalPredicate -> new( expr => $_[2] ) }
  | '[' num_list ']' { Bamboo::Engine::Parser::IndexPredicate -> new( list => $_[2] ) }
  ;

plist: '(' list ')' { $_[2] }
  ;

opt_plist: (plist)? { $_[1] }
  ;

primary_expr: DOLLAR_QNAME
  | DOLLAR_INT
  | plist
  | tuple
  | LITERAL
  | NUMBER
  | FUNCTION_NAME opt_plist
  ;

node_test: QNAME
  | NUMBER
  | '{' expr '}'
  | '*'
  ;

%%

use Bamboo::Engine::Block;
use Bamboo::Engine::Parser::BinExpr;
use Data::Dumper;

sub _Error {
}

my $SIMPLE_TOKENS = qr{\.\.|::|!=|>=|<=|\/\/|:=|\.|@|\*|\(|\)|\[|\]|\{|\}|\/|\||\+|-|=|>|<|&|,|;};
my $NCNAME = qr/[a-zA-Z_][-a-zA-Z0-9_.]*/;
my $QNAME = qr/(?:${NCNAME}:)?${NCNAME}/;
my $XMLNS = qr/xmlns:${NCNAME}/;
my $DOLLAR_QNAME = qr/\$${QNAME}/;

my %reserved_words = map { $_ => $_ } qw(
  for   
  return
  in    
  let   
  except
  every 
  some  
  satisfies
  if    
  then  
  else
  with 
  err  
  and  
  or   
  to   
  mod  
  div  
);


sub _Lexer {
  my($parser, $last) = @_;

  my($white_space, $new_line) = ();

  for($parser -> {_src}) {
    while( m/^(\s|\(:)/ ) {
      while( s/^\s// ) {
        if( s/^\n// ) {
          $new_line += 1;
          $parser -> {_line} += 1;
          $parser -> {_col} = 1;
        }
        else {
          $parser -> {_col} += 1;
        }
        $white_space += 1;
      }

      # skip comments delimited by (: :)
      # comments can be nested
      if( s/^\(:// ) {

        my $comment_depth = 1;
        $parser -> {_col} += 2;
        while( $comment_depth > 0 && $_ ne '' ) {
          if( s/^\(:// ) {
            $comment_depth += 1;
            $parser -> {_col} += 2;
          }
          if( s/^:\)// ) {
            $comment_depth -= 1;
            $parser -> {_col} += 2;
          }
          if( s/^\n// ) {
            $parser -> {_col} = 1;
            $parser -> {_line} += 1;
          }
          elsif( s/^.// ) {
            $parser -> {_col} += 1;
          }
        }

        if( $comment_depth > 0 ) {
          die "Unbalanced comment delimiters at line @{[$parser -> {_line}]}\n";
        }

        $white_space += 1;
      }
    }

    $_ eq '' and return ('', undef);

    if( $white_space ) {
      s/^\*// and return ('MPY', '*');
      s/^(${NCNAME})(?![\[\/])// and return ($reserved_words{$_} || 'QNAME', $_);
    }
    s/^(-?\d+(?:\.\d+)?|\.\d+)// and return ('NUMBER', $1);
    s/^($SIMPLE_TOKENS)// and return ($1, $1);
    s/^($DOLLAR_QNAME)// and return ('DOLLAR_QNAME', $1);
    s/^(\$\d+)// and return ('DOLLAR_INT', $1);
    s/^(${QNAME}\??\*?\s*(?=\([^:]))// and return ('FUNCTION_NAME', $1);
    s/^(${XMLNS})// and return ('XMLNS', $1);
    s/^(${QNAME})// and return ('QNAME', $1);
    s/^(${NCNAME})// and return ('NCNAME', $1);
  }
}

sub parse {
  my($self, $src, $debug) = @_;
  my $last = [ ];

  $self -> { _line } = 1;
  $self -> { _col } = 1;
  $self -> { _src } = $src;

  return $self -> YYParse(
    yylex => sub { $last = [_Lexer(shift, $last)]; $last },
    yyerror => \&_Error,
    yydebug => $debug,
  );
}
